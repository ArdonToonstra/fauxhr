@page "/acp/resources"
@using FauxHR.Core.Services
@using FauxHR.Modules.ExitStrategy.Services
@using Hl7.Fhir.Model
@using Hl7.Fhir.Serialization
@using System.Text.Json
@using Task = System.Threading.Tasks.Task
@using Blazored.LocalStorage
@inject AppState AppState
@inject ILocalStorageService LocalStorage
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime

<PageTitle>ACP Resources</PageTitle>

<div class="container-fluid py-4">
    <!-- Header -->
    <div class="d-flex justify-content-between align-items-center mb-4">
        <div>
            <h2 class="display-6 fw-bold text-primary mb-1">
                <i class="bi bi-database me-3"></i>Stored Resources
            </h2>
            <p class="lead text-muted mb-0">All retrieved ACP data grouped by resource type.</p>
        </div>
        <div class="d-flex gap-2">
            <button class="btn btn-outline-danger" @onclick="ClearCache">
                <i class="bi bi-trash me-2"></i>Clear Cache
            </button>
            <button class="btn btn-outline-secondary" @onclick='() => Navigation.NavigateTo("acp/overview")'>
                <i class="bi bi-arrow-left me-2"></i>Back to Overview
            </button>
        </div>
    </div>

    <!-- Sources Summary -->
    @if (sourceSummary.Any())
    {
        <div class="card border-0 shadow-sm mb-4">
            <div class="card-header bg-white border-bottom-0 pt-3">
                <div class="d-flex justify-content-between align-items-center">
                    <h5 class="fw-normal mb-0">Data Sources</h5>
                    @if (!string.IsNullOrEmpty(selectedSourceFilter))
                    {
                        <button class="btn btn-sm btn-outline-secondary" @onclick="() => selectedSourceFilter = string.Empty">
                            <i class="bi bi-x-circle me-1"></i>Clear Filter
                        </button>
                    }
                </div>
            </div>
            <div class="card-body">
                <div class="row g-3">
                    @foreach (var source in sourceSummary.OrderByDescending(s => s.Date))
                    {
                        <div class="col-md-6">
                            <div class="d-flex align-items-center p-2 rounded cursor-pointer @(selectedSourceFilter == GetSourceKey(source) ? "bg-primary-subtle border border-primary" : "bg-light")" 
                                 @onclick="() => FilterBySource(source)">
                                <i class="bi bi-server text-primary me-2"></i>
                                <div class="flex-fill">
                                    <div class="fw-bold small">@source.Source</div>
                                    <div class="text-xs text-muted">Retrieved: @source.Date.ToString("yyyy-MM-dd")</div>
                                </div>
                                <span class="badge bg-secondary">@source.Count resources</span>
                            </div>
                        </div>
                    }
                </div>
            </div>
        </div>
    }

    @if (AppState.CurrentPatient == null)
    {
        <div class="alert alert-warning shadow-sm border-0">
            <i class="bi bi-exclamation-triangle-fill me-2"></i>
            Please select a patient from the Dashboard to view resources.
        </div>
    }
    else if (isLoading)
    {
        <div class="text-center py-5">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <p class="mt-3 text-muted">Loading resources...</p>
        </div>
    }
    else if (groupedResources.Any())
    {
        @foreach (var group in GetFilteredResources().OrderBy(g => g.Key))
        {
            <div class="mb-5">
                <h3 class="fw-light mb-3">
                    <span class="badge bg-primary">@group.Value.Count</span>
                    @group.Key
                </h3>
                <div class="card shadow-sm border-0 overflow-hidden">
                    <div class="table-responsive">
                        <table class="table table-hover align-middle mb-0">
                            <thead class="bg-light text-secondary small text-uppercase">
                                <tr>
                                    <th class="ps-4 fw-medium border-0" style="width: 15%">Type</th>
                                    <th class="fw-medium border-0" style="width: 15%">Date</th>
                                    <th class="fw-medium border-0" style="width: 30%">Details</th>
                                    <th class="fw-medium border-0" style="width: 15%">ID</th>
                                    <th class="fw-medium border-0" style="width: 15%">Source</th>
                                    <th class="fw-medium border-0 text-end pe-4" style="width: 10%">Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                @foreach (var item in group.Value.OrderByDescending(r => r.RetrievalDate))
                                {
                                    <tr class="@(item.IsError ? "table-danger" : "")">
                                        <td class="ps-4">
                                            <span class="badge @(item.IsError ? "bg-danger" : "bg-secondary-subtle text-secondary border border-secondary-subtle") rounded-pill">
                                                @item.TypeName
                                            </span>
                                        </td>
                                        <td class="small text-muted">@GetResourceDate(item)</td>
                                        <td>
                                            <div class="text-truncate small" style="max-width: 350px;" title="@GetResourceSummary(item)">
                                                @GetResourceSummary(item)
                                            </div>
                                        </td>
                                        <td class="small text-muted font-monospace">
                                            <span class="d-inline-block text-truncate" style="max-width: 120px;" title="@item.ResourceId">
                                                @item.ResourceId
                                            </span>
                                        </td>
                                        <td class="small text-muted">
                                            <span class="d-inline-block text-truncate" style="max-width: 150px;" title="@item.Source">
                                                @GetShortSource(item.Source)
                                            </span>
                                        </td>
                                        <td class="text-end pe-4">
                                            <a role="button" class="text-primary text-decoration-none small fw-medium" @onclick="() => ViewSource(item)">
                                                View Source
                                            </a>
                                        </td>
                                    </tr>
                                }
                            </tbody>
                        </table>
                    </div>
                </div>
                <hr class="my-4 text-muted opacity-25" />
            </div>
        }
    }
    else
    {
        <div class="alert alert-info shadow-sm border-0">
            <i class="bi bi-info-circle-fill me-2"></i>
            No resources found. Return to the Overview page and click "Pull Latest Info" to retrieve data.
        </div>
    }
</div>

<!-- Enhanced Source Viewer Modal -->
@if (showSourceModal && selectedResource != null)
{
    <div class="modal fade show d-block" tabindex="-1" style="background-color: rgba(0,0,0,0.7);">
        <div class="modal-dialog modal-xl modal-dialog-scrollable">
            <div class="modal-content">
                <div class="modal-header @(selectedResource.IsError ? "bg-danger text-white" : "")">
                    <h5 class="modal-title">
                        @(selectedResource.IsError ? "Error: " : "")@selectedResource.TypeName - @selectedResource.ResourceId
                    </h5>
                    <button type="button" class="btn-close @(selectedResource.IsError ? "btn-close-white" : "")" @onclick="CloseSourceModal"></button>
                </div>
                <div class="modal-body p-0">
                    <pre class="m-0 p-3 bg-dark text-light" style="font-size: 0.85rem; line-height: 1.4;"><code>@selectedResource.JsonSource</code></pre>
                </div>
                <div class="modal-footer">
                    <div class="me-auto small text-muted">
                        <i class="bi bi-calendar me-1"></i>Retrieved: @selectedResource.RetrievalDate.ToString("yyyy-MM-dd HH:mm")
                        <span class="mx-2">|</span>
                        <i class="bi bi-server me-1"></i>@selectedResource.Source
                    </div>
                    <button type="button" class="btn btn-secondary" @onclick="CloseSourceModal">Close</button>
                </div>
            </div>
        </div>
    </div>
}

@code {
    private bool isLoading = true;
    private Dictionary<string, List<StoredResource>> groupedResources = new();
    private List<SourceSummary> sourceSummary = new();
    private string selectedSourceFilter = string.Empty;
    
    // Modal state
    private bool showSourceModal = false;
    private StoredResource? selectedResource;

    protected override async Task OnInitializedAsync()
    {
        await LoadResourcesFromStorage();
    }

    private Dictionary<string, List<StoredResource>> GetFilteredResources()
    {
        if (string.IsNullOrEmpty(selectedSourceFilter))
        {
            return groupedResources;
        }

        var filtered = new Dictionary<string, List<StoredResource>>();
        foreach (var group in groupedResources)
        {
            var filteredList = group.Value
                .Where(r => GetSourceKey(r.Source, r.RetrievalDate.Date) == selectedSourceFilter)
                .ToList();
            
            if (filteredList.Any())
            {
                filtered[group.Key] = filteredList;
            }
        }
        return filtered;
    }

    private void FilterBySource(SourceSummary source)
    {
        var key = GetSourceKey(source);
        selectedSourceFilter = selectedSourceFilter == key ? string.Empty : key;
    }

    private string GetSourceKey(SourceSummary source) => GetSourceKey(source.Source, source.Date);
    
    private string GetSourceKey(string source, DateTime date) => $"{source}|{date:yyyyMMdd}";

    private string GetShortSource(string source)
    {
        if (string.IsNullOrEmpty(source) || source == "Unknown") return "-";
        try
        {
            var uri = new Uri(source);
            return uri.Host;
        }
        catch
        {
            // If it's not a valid URI, just return truncated version
            return source.Length > 30 ? source[..27] + "..." : source;
        }
    }

    private string GetResourceDate(StoredResource item)
    {
        if (string.IsNullOrWhiteSpace(item.JsonSource)) return "-";
        
        try
        {
            using var doc = JsonDocument.Parse(item.JsonSource);
            var root = doc.RootElement;
            
            // Try common date fields based on resource type
            switch (item.TypeName)
            {
                case "QuestionnaireResponse":
                    if (root.TryGetProperty("authored", out var authored))
                        return FormatDate(authored.GetString());
                    break;
                case "Procedure":
                    if (root.TryGetProperty("performedDateTime", out var performed))
                        return FormatDate(performed.GetString());
                    if (root.TryGetProperty("performedPeriod", out var period) && 
                        period.TryGetProperty("start", out var start))
                        return FormatDate(start.GetString());
                    break;
                case "Encounter":
                    if (root.TryGetProperty("period", out var encPeriod) && 
                        encPeriod.TryGetProperty("start", out var encStart))
                        return FormatDate(encStart.GetString());
                    break;
                case "Observation":
                    if (root.TryGetProperty("effectiveDateTime", out var effective))
                        return FormatDate(effective.GetString());
                    break;
                case "Consent":
                    if (root.TryGetProperty("dateTime", out var dateTime))
                        return FormatDate(dateTime.GetString());
                    break;
                case "Condition":
                    if (root.TryGetProperty("recordedDate", out var recorded))
                        return FormatDate(recorded.GetString());
                    if (root.TryGetProperty("onsetDateTime", out var onset))
                        return FormatDate(onset.GetString());
                    break;
                case "DocumentReference":
                    if (root.TryGetProperty("date", out var docDate))
                        return FormatDate(docDate.GetString());
                    break;
            }
            
            // Fallback to meta.lastUpdated
            if (root.TryGetProperty("meta", out var meta) && 
                meta.TryGetProperty("lastUpdated", out var lastUpdated))
                return FormatDate(lastUpdated.GetString());
        }
        catch { }
        
        return item.RetrievalDate.ToString("yyyy-MM-dd");
    }

    private string FormatDate(string? dateStr)
    {
        if (string.IsNullOrEmpty(dateStr)) return "-";
        if (DateTime.TryParse(dateStr, out var dt))
            return dt.ToString("yyyy-MM-dd");
        // Return first 10 chars if it looks like a date
        return dateStr.Length >= 10 ? dateStr[..10] : dateStr;
    }

    private string GetResourceSummary(StoredResource item)
    {
        if (string.IsNullOrWhiteSpace(item.JsonSource)) return "";
        
        try
        {
            using var doc = JsonDocument.Parse(item.JsonSource);
            var root = doc.RootElement;
            
            switch (item.TypeName)
            {
                case "QuestionnaireResponse":
                    if (root.TryGetProperty("questionnaire", out var questionnaire))
                        return questionnaire.GetString() ?? "";
                    break;
                case "Procedure":
                    return GetCodeDisplay(root, "code");
                case "Encounter":
                    if (root.TryGetProperty("type", out var types) && types.GetArrayLength() > 0)
                        return GetCodeableConceptDisplay(types[0]);
                    break;
                case "Observation":
                    return GetCodeDisplay(root, "code");
                case "Consent":
                    if (root.TryGetProperty("status", out var status))
                        return $"Status: {status.GetString()}";
                    break;
                case "Condition":
                    return GetCodeDisplay(root, "code");
                case "DocumentReference":
                    if (root.TryGetProperty("description", out var desc))
                        return desc.GetString() ?? "";
                    return GetCodeDisplay(root, "type");
                case "Patient":
                    return GetPatientName(root);
                case "Practitioner":
                    return GetPractitionerName(root);
                case "Organization":
                    if (root.TryGetProperty("name", out var orgName))
                        return orgName.GetString() ?? "";
                    break;
                case "OperationOutcome":
                    return GetOperationOutcomeSummary(root);
            }
        }
        catch { }
        
        return "";
    }

    private string GetCodeDisplay(JsonElement root, string propertyName)
    {
        if (root.TryGetProperty(propertyName, out var code))
            return GetCodeableConceptDisplay(code);
        return "";
    }

    private string GetCodeableConceptDisplay(JsonElement codeableConcept)
    {
        if (codeableConcept.TryGetProperty("text", out var text))
            return text.GetString() ?? "";
        if (codeableConcept.TryGetProperty("coding", out var coding) && coding.GetArrayLength() > 0)
        {
            var firstCoding = coding[0];
            if (firstCoding.TryGetProperty("display", out var display))
                return display.GetString() ?? "";
            if (firstCoding.TryGetProperty("code", out var codeVal))
                return codeVal.GetString() ?? "";
        }
        return "";
    }

    private string GetPatientName(JsonElement root)
    {
        if (root.TryGetProperty("name", out var names) && names.GetArrayLength() > 0)
        {
            var name = names[0];
            var parts = new List<string>();
            if (name.TryGetProperty("given", out var given))
                foreach (var g in given.EnumerateArray())
                    parts.Add(g.GetString() ?? "");
            if (name.TryGetProperty("family", out var family))
                parts.Add(family.GetString() ?? "");
            return string.Join(" ", parts.Where(p => !string.IsNullOrEmpty(p)));
        }
        return "";
    }

    private string GetPractitionerName(JsonElement root)
    {
        return GetPatientName(root); // Same structure
    }

    private string GetOperationOutcomeSummary(JsonElement root)
    {
        if (root.TryGetProperty("issue", out var issues) && issues.GetArrayLength() > 0)
        {
            var issue = issues[0];
            if (issue.TryGetProperty("diagnostics", out var diag))
                return diag.GetString() ?? "Error";
            if (issue.TryGetProperty("details", out var details))
                return GetCodeableConceptDisplay(details);
        }
        return "Operation Outcome";
    }

    private async Task LoadResourcesFromStorage()
    {
        isLoading = true;
        groupedResources.Clear();
        sourceSummary.Clear();

        try
        {
            var keys = await LocalStorage.KeysAsync();
            
            foreach (var key in keys)
            {
                // Basic check to ensure it's likely a resource key (not setting/config)
                // New format: slug_Type_Id. Old: Type-Id-Date.
                // We'll rely on being able to parse it as a FHIR resource.
                
                var jsonSource = await LocalStorage.GetItemAsStringAsync(key);
                if (string.IsNullOrWhiteSpace(jsonSource)) continue;

                // Ignore small config values
                if (jsonSource.Length < 10 || !jsonSource.TrimStart().StartsWith("{")) continue;

                string resourceType = "Unknown";
                string resourceId = "Unknown";
                string source = "Unknown";
                DateTime retrievalDate = DateTime.MinValue;
                bool isError = false;

                try
                {
                    using var doc = JsonDocument.Parse(jsonSource);
                    var root = doc.RootElement;
                    
                    if (root.TryGetProperty("resourceType", out var typeProp))
                    {
                        resourceType = typeProp.GetString() ?? "Unknown";
                    }
                    else continue; // Not a FHIR resource

                    if (root.TryGetProperty("id", out var idProp))
                    {
                        resourceId = idProp.GetString() ?? "Unknown";
                    }

                    if (root.TryGetProperty("meta", out var meta))
                    {
                        if (meta.TryGetProperty("source", out var sourceProp))
                        {
                            source = sourceProp.GetString() ?? "Unknown";
                        }
                        
                        // Use lastUpdated as "retrieval date" for sorting/grouping, 
                        // or fallback to a default if missing.
                        if (meta.TryGetProperty("lastUpdated", out var dateProp) && 
                            dateProp.TryGetDateTime(out var dt))
                        {
                            retrievalDate = dt;
                        }
                    }

                    isError = resourceType == "OperationOutcome";
                }
                catch 
                {
                    // Fallback to key parsing if JSON fails (legacy support?)
                    // Or just skip.
                    continue; 
                }

                // If date still missing, maybe try key pattern for legacy data
                if (retrievalDate == DateTime.MinValue)
                {
                    var parts = key.Split('-');
                    if (parts.Length >= 3 && parts[^1].Length == 8 && int.TryParse(parts[^1], out _))
                    {
                         DateTime.TryParseExact(parts[^1], "yyyyMMdd", null, System.Globalization.DateTimeStyles.None, out retrievalDate);
                    }
                    
                    if (retrievalDate == DateTime.MinValue) retrievalDate = DateTime.Now; // Final fallback
                }

                var resource = new StoredResource
                {
                    TypeName = resourceType,
                    ResourceId = resourceId,
                    RetrievalDate = retrievalDate,
                    Source = source,
                    JsonSource = jsonSource,
                    IsError = isError
                };

                if (!groupedResources.ContainsKey(resourceType))
                {
                    groupedResources[resourceType] = new List<StoredResource>();
                }
                groupedResources[resourceType].Add(resource);
            }
            
            // Build source summary
            var sources = groupedResources
                .SelectMany(g => g.Value)
                .GroupBy(r => new { r.Source, Date = r.RetrievalDate.Date })
                .Select(g => new SourceSummary 
                { 
                    Source = g.Key.Source, 
                    Date = g.Key.Date,
                    Count = g.Count() 
                })
                .ToList();
            
            sourceSummary = sources;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading resources: {ex.Message}");
        }

        isLoading = false;
    }

    private async Task ClearCache()
    {
        if (await JSRuntime.InvokeAsync<bool>("confirm", "Are you sure you want to clear all cached resources? This cannot be undone."))
        {
            try
            {
                await LocalStorage.ClearAsync();
                selectedSourceFilter = string.Empty;
                await LoadResourcesFromStorage();
                StateHasChanged();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error clearing cache: {ex.Message}");
            }
        }
    }

    private void ViewSource(StoredResource resource)
    {
        selectedResource = resource;
        showSourceModal = true;
    }

    private void CloseSourceModal()
    {
        showSourceModal = false;
        selectedResource = null;
    }

    private class StoredResource
    {
        public string TypeName { get; set; } = string.Empty;
        public string ResourceId { get; set; } = string.Empty;
        public DateTime RetrievalDate { get; set; }
        public string Source { get; set; } = string.Empty;
        public string JsonSource { get; set; } = string.Empty;
        public bool IsError { get; set; }
    }
    
    private class SourceSummary
    {
        public string Source { get; set; } = string.Empty;
        public DateTime Date { get; set; }
        public int Count { get; set; }
    }
}
